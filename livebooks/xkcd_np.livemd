# xkcd-np

```elixir
Mix.install([:fixpoint])
```

## How do you solve with Constraint Programming?

#### [**xkcd**](https://xkcd.com/287/), as always, helps us to explain things :-)

![image](https://imgs.xkcd.com/comics/np_complete.png)

## Solving customer request for appetizers

### First, create a model for the problem.

Meaning we declare the decision variables and the constraints over them.

* The decision variables are the quantities per appetizer
* The single constraint is that the total price of the appetizers is exactly what the customers require.

```elixir
defmodule XKCD.NP.Appetizers do
  alias CPSolver.IntVariable, as: Variable
  alias CPSolver.Model
  alias CPSolver.Constraint.Sum
  import CPSolver.Variable.View.Factory

  def model() do
    appetizers = [
      {:mixed_fruit, 215},
      {:french_fries, 275},
      {:side_salad, 335},
      {:hot_wings, 355},
      {:mozarella_sticks, 420},
      {:sampler_plate, 580}
    ]

    total = 1505

    ## We want to find the quantities for each appetizer...
    quantities =
      Enum.map(appetizers, fn {name, price} ->
        mul(Variable.new(0..div(total, price), name: name), price)
      end)

    total_price = Variable.new([total], name: :total)

    ### ...such that the total price will be exactly as the customers ask
    ###
    Model.new(
      quantities,
      [Sum.new(total_price, quantities)]
    )
  end

  def print_solutions(solver_results) do
    (Enum.map_join(solver_results.solutions, "\n OR \n", fn sol ->
       sol
       |> Enum.zip(solver_results.variables)
       |> Enum.reject(fn {q, _name} -> q == 0 end)
       |> Enum.map_join(", ", fn {q, name} ->
         IO.ANSI.red() <> "#{name} : #{IO.ANSI.blue()}#{q}"
       end)
     end) <> IO.ANSI.reset())
    |> IO.puts()
  end
end
```

#### Once we have a model, we feed it to a solver.

```elixir
alias XKCD.NP.Appetizers
## Solve
{:ok, res} = CPSolver.solve_sync(Appetizers.model())
## Present results
Appetizers.print_solutions(res)

IO.puts("Solver status: #{res.status}")
```

### That's it! Two solutions are available.

## Serving tables as fast as possible

We want to minimize the total distance the waiter walks to serve the tables.

We will use model that solves Travelling Salesman Problem:

https://github.com/bokner/fixpoint/blob/main/lib/examples/tsp.ex

```elixir
alias CPSolver.Examples.TSP

tables = ["Table 1", "Table 2", "Table 3", "Table 4", "Table 5", "Table 6", "Table 7"]

## distances[i, j] is a distance from table i to table j
distances = [
  [0, 2, 3, 4, 5, 2, 3],
  [2, 0, 1, 5, 4, 3, 5],
  [3, 1, 0, 5, 5, 3, 5],
  [4, 5, 5, 0, 4, 6, 3],
  [5, 4, 5, 4, 0, 6, 6],
  [2, 3, 3, 6, 6, 0, 4],
  [3, 5, 5, 3, 6, 4, 0]
]

model = TSP.model(distances)
{:ok, result} = CPSolver.solve_sync(model)

optimal_solution = result.solutions |> List.last()

optimal_route = TSP.to_route(optimal_solution, model)

IO.puts(
  Enum.map_join(optimal_route, " \u2b95 ", fn idx -> "[" <> Enum.at(tables, idx) <> "]" end)
)

IO.puts("\n")
IO.puts("Start from where you are, and follow the directions :-)")
```
